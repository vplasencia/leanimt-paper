% \documentclass{} is the first command in any LaTeX code.  
% It is used to define what kind of document you are creating 
% such as an article or a book, and begins the document preamble
\documentclass{article} 

% Packages for customizing the ToC
\usepackage{tocloft}
\usepackage{xcolor} % Package for color definitions
\usepackage{hyperref}

% Create trees
\usepackage{forest}

% Create two column content
\usepackage{multicol}

% Put blocks at their specific place using [H]
\usepackage{float}

\usepackage{algorithm}% http://ctan.org/pkg/algorithms
\usepackage{algpseudocode}% http://ctan.org/pkg/algorithmicx

% Add dots to the table of contents
\renewcommand{\cftsecleader}{\cftdotfill{\cftdotsep}}
\renewcommand{\cftsubsecleader}{\cftdotfill{\cftdotsep}}
\renewcommand{\cftsubsubsecleader}{\cftdotfill{\cftdotsep}}

% Define custom colors using xcolor
\definecolor{blue600}{HTML}{2563eb}
\definecolor{blue700}{HTML}{1d4ed8}

% Hyperlink settings
\hypersetup{
    % Enable colored links
    colorlinks=true,
    % Color for internal links (sections, pages, etc.)
    linkcolor=blue700,
    % Color for external URLs
    urlcolor=blue600,
    % Color for citation links
    citecolor=blue700
}

% Bibliography package
\usepackage[backend=biber,style=numeric]{biblatex}
\addbibresource{references.bib}

% Article title
\title{LeanIMT: An optimized Incremental Merkle Tree} 
% Authors name
\author{Privacy \& Scaling Explorations} 
% Date for date compiled
\date{\today} 

% The preamble ends with the command \begin{document}
% All begin commands must be paired with an end command somewhere
\begin{document}
% Creates title using information in preamble (title, author, date)
\maketitle

% Creates a section for the Abstract
\section{Abstract}

% Insert a new page
\newpage
% Insert the Table of Contents
\tableofcontents
% Insert a new page
\newpage

% Creates a section for the Introduction
\section{Introduction}

% Creates a subsection for the Motivation within Introduction
\subsection{Motivation}

\section{Merkle Tree}

\subsection{Incremental Merkle Tree}

An Incrememental Merkle Tree (IMT) is a Merkle Tree (MT) designed to be updated efficiently.

% align to the left
\raggedright

\bigbreak

\subsection{Binary Tree}

A Binary Tree is a tree data structure in which each node has at most two children, referred to as the left child and the right child.

TODO: Explain what is a Merkle tree and an Incremental Merkle Tree.

% Add a new empty line
\bigbreak

% Generic Merkle Tree 

\begin{center}
    \begin{forest}
        for tree={edge path={\noexpand\path[\forestoption{edge}] (\forestOve{\forestove{@parent}}{name}.parent anchor) -- +(0,-18pt)-| (\forestove{name}.child anchor)\forestoption{edge label};}, rectangle, draw, align=center}
        [$H_6$ \\ \color{blue600}H($H_4{||}H_5$)
        [$H_4$ \\ \color{blue600}H($H_0{||}H_1$) [$H_0$ \\ \color{blue600}H($a_0{||}a_1$) [$a_0$] [$a_1$]] [$H_1$ \\ \color{blue600}H($a_2{||}a_3$) [$a_2$] [$a_3$]]]
        [$H_5$ \\ \color{blue600}H($H_2{||}H_3$) [$H_2$ \\ \color{blue600}H($a_4{||}a_5$) [$a_4$] [$a_5$]] [$H_3$ \\ \color{blue600}H($H_6{||}H_7$) [$a_6$] [$a_7$]]]
        ]
    \end{forest}
\end{center}

\bigbreak

\section{LeanIMT}

\subsection{Definition}

\bigbreak

The \textbf{LeanIMT} (Lean Incremental Merkle Tree) is a Binary IMT.

\bigbreak

% align to the left
\raggedright

The LeanIMT has two properties:

1. Every node with two children is the hash of its two child nodes.

2. Every node with one child has the same value as its child node.

\bigbreak

Example of a LeanIMT

\bigbreak

$T$ - Tree

$V$ - Vertices (Nodes)

$E$ - Edges (Lines connecting Nodes)

\bigbreak

$T = (V,E)$

% align to the left
\raggedright

\bigbreak

$V = \{a_0, a_1, a_2, H_0, H_1, H_2\}$

\bigbreak

$E = \{(a_0, H_0), (a_1, H_0), (a_2, a_2), (H_0, H_1), (a_2, a_2)\}$

\bigbreak

\begin{center}
    \begin{forest}
        for tree={edge path={\noexpand\path[\forestoption{edge}] (\forestOve{\forestove{@parent}}{name}.parent anchor) -- +(0,-18pt)-| (\forestove{name}.child anchor)\forestoption{edge label};}, rectangle, draw, align=center}
        [$H_1$ \\ \color{blue600}H($H_0{||}a_2$)
        [$H_0$ \\ \color{blue600}H($a_0{||}a_1$)
        [$a_0$]
            [$a_1$]
        ]
        [$a_2$ \\ \color{blue600}$a_2$
        [$a_2$]
        ]
        ]
    \end{forest}
\end{center}

\bigbreak

\subsection{Insertion}

There are two cases:

1. When the new node is a left node.

2. When the new node is a right node.

\bigbreak

We will always see one of these cases in each level when we are inserting a node. It is like, when you insert a node, if that node is left node, the parent node which is in the next level, will be the same node. If it is a right node the parent node, will be the hash of this node with the node in its left. This algorithm will be the same in each level, not only in level 0.

\bigbreak

\subsection*{Case 1: The new node is a left node}

It will not be hashed, it's value will be sent to the next level.

\bigbreak

If we add $a_4$.

\bigbreak

$T = (V,E)$

% align to the left
\raggedright

\bigbreak

$V = \{a_0, a_1, a_2, a_3, H_0, H_1, H_2\}$

\bigbreak

$E = \{(a_0, H_0), (a_1, H_0), (a_2, H_1), (a_3, H_1), (H_0, H_2), (H_1, H_2)\}$

\bigbreak
\bigbreak
\bigbreak

\begin{multicols}{2}
    \vfill
    \columnbreak
    \vspace*{\fill}
    \begin{center}
        \begin{forest}
            for tree={edge path={\noexpand\path[\forestoption{edge}] (\forestOve{\forestove{@parent}}{name}.parent anchor) -- +(0,-12pt)-| (\forestove{name}.child anchor)\forestoption{edge label};}, rectangle, draw, align=center}
            [$H_2$
            [$H_0$
                    [$a_0$]
                        [$a_1$]
                ]
                [$H_1$
                    [$a_2$]
                        [$a_3$]
                ]
            ]
        \end{forest}
    \end{center}
    \begin{center}
        \textit{Before inserting $a_4$}
    \end{center}
    \begin{center}
        \begin{forest}
            for tree={edge path={\noexpand\path[\forestoption{edge}] (\forestOve{\forestove{@parent}}{name}.parent anchor) -- +(0,-12pt)-| (\forestove{name}.child anchor)\forestoption{edge label};}, rectangle, draw, align=center}
            [$H_3$, draw=blue600, top color=blue600!0, bottom color=blue600!0
            [
            $H_2$ [$H_0$ [$a_0$] [$a_1$]] [$H_1$ [$a_2$] [$a_3$]]
            ]
            [$a_4$ , edge=blue600, draw=blue600, top color=blue600!0, bottom color=blue600!0 [$a_4$ , edge=blue600, draw=blue600, top color=blue600!0, bottom color=blue600!0 [$a_4$ , edge=blue600, draw=blue600, top color=blue600!0, bottom color=blue600!0]]]
            ]
        \end{forest}
    \end{center}
    \begin{center}
        \textit{After inserting $a_4$}
    \end{center}
\end{multicols}

\bigbreak

\subsection*{Case 2: The new node is a right node}

\bigbreak

If we add $a_5$.

\bigbreak

\begin{multicols}{2}

    % Fill a space
    \vfill
    \columnbreak
    \vspace*{\fill}
    % Fill a space

    \begin{center}
        \begin{forest}
            for tree={edge path={\noexpand\path[\forestoption{edge}] (\forestOve{\forestove{@parent}}{name}.parent anchor) -- +(0,-12pt)-| (\forestove{name}.child anchor)\forestoption{edge label};}, rectangle, draw, align=center}
            [$H_3$
            [
                    $H_2$ [$H_0$ [$a_0$] [$a_1$]] [$H_1$ [$a_2$] [$a_3$]]
                ]
                [$a_4$ [$a_4$ [$a_4$]]]
            ]
        \end{forest}
    \end{center}
    \begin{center}
        \textit{Before inserting $a_5$}
    \end{center}
    % Fill a space
    \vfill
    \columnbreak
    \vspace*{\fill}
    % Fill a space
    \begin{center}
        \begin{forest}
            for tree={edge path={\noexpand\path[\forestoption{edge}] (\forestOve{\forestove{@parent}}{name}.parent anchor) -- +(0,-12pt)-| (\forestove{name}.child anchor)\forestoption{edge label};}, rectangle, draw, align=center}
            [$H_5$, draw=blue600, top color=blue600!0, bottom color=blue600!0
            [
            $H_2$ [$H_0$ [$a_0$] [$a_1$]] [$H_1$ [$a_2$] [$a_3$]]
            ]
            [$H_4$ , edge=blue600, draw=blue600, top color=blue600!0, bottom color=blue600!0 [$H_4$ , edge=blue600, draw=blue600, top color=blue600!0, bottom color=blue600!0 [$a_4$] [$a_5$ , edge=blue600, draw=blue600, top color=blue600!0, bottom color=blue600!0]]]
            ]
        \end{forest}
    \end{center}
    \begin{center}
        \textit{After inserting $a_5$}
    \end{center}
\end{multicols}

\bigbreak

\subsubsection{Pseudocode}

\begin{algorithm}[H]
    \caption{LeanIMT Insert algorithm}\label{insert}
    \begin{algorithmic}[1]
        \Procedure{Insert}{$leaf$}
        \If{$depth < newDepth$} \Comment{$newDepth$ is the new depth of the tree after inserting the new node}
        \State add a new empty array to nodes \Comment{Add a new tree level}
        \EndIf
        \State $node\gets leaf$
        \State $index\gets size$ \Comment{The index of the new leaf equals the number of leaves in the tree.}
        \For{level from 0 to depth - 1}
        \State nodes[level][index] $\gets$ node
        \If{index \textbf{is odd}} \Comment{It's a right node}
        \State sibling $\gets$ nodes[level][index - 1]
        \State node $\gets$ \textbf{hash}(sibling, node)
        \EndIf
        \State index $\gets$ $\lfloor index/2 \rfloor$ \Comment{Divides the index by 2 and discards the remainder.}
        \EndFor
        \State nodes[depth] $\gets$ [node] \Comment{Store the new root at the top level}
        \EndProcedure
    \end{algorithmic}
\end{algorithm}

\bigbreak

\subsection{Batch Insertion}

Performing the insertion in bulk rather than individually using a loop can lead to significant performance improvements. This optimization stems from the reduced number of hashing operations required. By inserting many elements at once, the algorithm can minimize redundant computations and manage memory more efficiently, resulting in faster execution and better overall performance.

\bigbreak

When inserting $n$ members, all levels will be updated $n$ times if the batch insertion function is not being used.

The core idea behind the batch insertion algorithm is to update each level only once even if there are many members to be inserted.

The algorithm will go through the nodes that are necessary to update the next level of the tree. The other nodes in the tree won't be used or changed.

\bigbreak

Insert $a_4$ and $a_5$.

\bigbreak

\begin{multicols}{2}
    \vfill
    \columnbreak
    \vspace*{\fill}
    \begin{center}
        \begin{forest}
            for tree={edge path={\noexpand\path[\forestoption{edge}] (\forestOve{\forestove{@parent}}{name}.parent anchor) -- +(0,-12pt)-| (\forestove{name}.child anchor)\forestoption{edge label};}, rectangle, draw, align=center}
            [$H_2$
            [$H_0$
                    [$a_0$]
                        [$a_1$]
                ]
                [$H_1$
                    [$a_2$]
                        [$a_3$]
                ]
            ]
        \end{forest}
    \end{center}
    \begin{center}
        \textit{Before inserting $a_4$ and $a_5$}
    \end{center}
    \begin{center}
        \begin{forest}
            for tree={edge path={\noexpand\path[\forestoption{edge}] (\forestOve{\forestove{@parent}}{name}.parent anchor) -- +(0,-12pt)-| (\forestove{name}.child anchor)\forestoption{edge label};}, rectangle, draw, align=center}
            [$H_4$, draw=blue600, top color=blue600!0, bottom color=blue600!0
            [
            $H_2$ [$H_0$ [$a_0$] [$a_1$]] [$H_1$ [$a_2$] [$a_3$]]
            ]
            [$H_3$ , edge=blue600, draw=blue600, top color=blue600!0, bottom color=blue600!0 [$H_3$ , edge=blue600, draw=blue600, top color=blue600!0, bottom color=blue600!0 [$a_4$ , edge=blue600, draw=blue600, top color=blue600!0, bottom color=blue600!0] [$a_5$ , edge=blue600, draw=blue600, top color=blue600!0, bottom color=blue600!0]]]
            ]
        \end{forest}
    \end{center}
    \begin{center}
        \textit{After inserting $a_4$ and $a_5$}
    \end{center}
\end{multicols}

\bigbreak

\subsubsection{Pseudocode}

\begin{algorithm}[H]
    \caption{LeanIMT InsertMany algorithm}\label{insertMany}
    \begin{algorithmic}[1]
        \Procedure{InsertMany}{$leaves$: List of nodes}
        \State $startIndex$ $\gets$ $\lfloor size/2 \rfloor$ \Comment{Divides the size of the tree by 2 and discards the remainder.}
        \State Add $leaves$ to the tree leaves

        \For{level from 0 to depth - 1}
        \State numberOfNodes $\gets$ $\lceil nodes[level].length / 2 \rceil$ \Comment{ Calculate the number of nodes of the next level. numberOfNodes will be the smallest integrer which is greater than or equal to the result of dividing the number of nodes of the level by 2.}
        \For{index from $startIndex$ to numberOfNodes - 1}
        \State rightNode $\gets$ nodes[level][index * 2 + 1] \Comment{Get the right node if exists.}
        \State leftNode $\gets$ nodes[level][index * 2] \Comment{Get the left node if exists.}
        \If{$rightNode$ exists}
        \State parentNode $\gets$ $hash(leftNode, rightNode)$
        \Else
        \State parentNode $\gets$ $leftNode$
        \EndIf
        \State nodes[level + 1][index] $\gets$ parentNode \Comment{Add the parent node to the tree.}
        \EndFor
        \State startIndex $\gets$ $\lfloor startIndex/2 \rfloor$ \Comment{Divide startIndex by 2 and discards the remainder.}
        \EndFor
        \EndProcedure
    \end{algorithmic}
\end{algorithm}

\bigbreak

\subsection{Update}

There are two cases:

1. When there is no right sibling.

2. When there is right sibling.

\subsection*{Case 1: There is no right sibling}

\bigbreak

Update $a_4$ to $a_5$

\bigbreak

\begin{multicols}{2}
    \vfill
    \columnbreak
    \vspace*{\fill}
    \begin{center}
        \begin{forest}
            for tree={edge path={\noexpand\path[\forestoption{edge}] (\forestOve{\forestove{@parent}}{name}.parent anchor) -- +(0,-12pt)-| (\forestove{name}.child anchor)\forestoption{edge label};}, rectangle, draw, align=center}
            [$H_3$
            [
                    $H_2$ [$H_0$ [$a_0$] [$a_1$]] [$H_1$ [$a_2$] [$a_3$]]
                ]
                [$a_4$ [$a_4$ [$a_4$]]]
            ]
        \end{forest}
    \end{center}
    \begin{center}
        \textit{Before updating $a_4$}
    \end{center}
    % Fill a space
    \vfill
    \columnbreak
    \vspace*{\fill}
    % Fill a space
    \begin{center}
        \begin{forest}
            for tree={edge path={\noexpand\path[\forestoption{edge}] (\forestOve{\forestove{@parent}}{name}.parent anchor) -- +(0,-12pt)-| (\forestove{name}.child anchor)\forestoption{edge label};}, rectangle, draw, align=center}
            [$H_4$, draw=blue600, top color=blue600!0, bottom color=blue600!0
            [
            $H_2$ [$H_0$ [$a_0$] [$a_1$]] [$H_1$ [$a_2$] [$a_3$]]
            ]
            [$a_5$ , edge=blue600, draw=blue600, top color=blue600!0, bottom color=blue600!0 [$a_5$ , edge=blue600, draw=blue600, top color=blue600!0, bottom color=blue600!0 [$a_5$ , edge=blue600, draw=blue600, top color=blue600!0, bottom color=blue600!0]]]
            ]
        \end{forest}
    \end{center}
    \begin{center}
        \textit{After updating $a_4$}
    \end{center}
\end{multicols}

\bigbreak

\subsection*{Case 2: There is right sibling}

\bigbreak

Update $a_2$ to $a_5$

\bigbreak

\begin{multicols}{2}
    \vfill
    \columnbreak
    \vspace*{\fill}
    \begin{center}
        \begin{forest}
            for tree={edge path={\noexpand\path[\forestoption{edge}] (\forestOve{\forestove{@parent}}{name}.parent anchor) -- +(0,-12pt)-| (\forestove{name}.child anchor)\forestoption{edge label};}, rectangle, draw, align=center}
            [$H_3$
            [
                    $H_2$ [$H_0$ [$a_0$] [$a_1$]] [$H_1$ [$a_2$] [$a_3$]]
                ]
                [$a_4$ [$a_4$ [$a_4$]]]
            ]
        \end{forest}
    \end{center}
    \begin{center}
        \textit{Before updating $a_2$ for $a_5$}
    \end{center}
    % Fill a space
    \vfill
    \columnbreak
    \vspace*{\fill}
    % Fill a space
    \begin{center}
        \begin{forest}
            for tree={edge path={\noexpand\path[\forestoption{edge}] (\forestOve{\forestove{@parent}}{name}.parent anchor) -- +(0,-12pt)-| (\forestove{name}.child anchor)\forestoption{edge label};}, rectangle, draw, align=center}
            [$H_3$, draw=blue600, top color=blue600!0, bottom color=blue600!0
            [
            $H_5$, edge=blue600, draw=blue600, top color=blue600!0, bottom color=blue600!0 [$H_0$ [$a_0$] [$a_1$]] [$H_4$, edge=blue600, draw=blue600, top color=blue600!0, bottom color=blue600!0 [$a_5$, edge=blue600, draw=blue600, top color=blue600!0, bottom color=blue600!0] [$a_3$]]
            ]
            [$a_4$ [$a_4$ [$a_4$]]]
            ]
        \end{forest}
    \end{center}
    \begin{center}
        \textit{After updating $a_2$ for $a_5$}
    \end{center}
\end{multicols}

\bigbreak

\subsubsection{Pseudocode}

\begin{algorithm}[H]
    \caption{LeanIMT Update algorithm}\label{update}
    \begin{algorithmic}[1]
        \Procedure{Update}{$index$, $newLeaf$}
        \State $node\gets newLeaf$
        \For{level from 0 to depth - 1}
        \State nodes[level][index] $\gets$ node
        \If{index \textbf{is odd}} \Comment{It's a right node}
        \State sibling $\gets$ nodes[level][index - 1]
        \State node $\gets$ \textbf{hash}(sibling, node)
        \Else \Comment{It's a left node}
        \State sibling $\gets$ nodes[level][index + 1]
        \If{sibling exists} \Comment{It's a left node with a right sibling}
        \State node $\gets$ hash(node, sibling)
        \EndIf
        \EndIf
        \State index $\gets$ $\lfloor index/2 \rfloor$ \Comment{Divides the index by 2 and discards the remainder.}
        \EndFor
        \State nodes[depth] $\gets$ [node] \Comment{Store the new root at the top level}
        \EndProcedure
    \end{algorithmic}
\end{algorithm}

\bigbreak

\subsection{Remove}

The \textit{remove} function is the same as the \textit{update} function but the value used to update is 0.

You can use a value other than 0, the idea is to use a value that is not a possible value for a correct member in the list.

\bigbreak

Remove $a_2$

\bigbreak

\begin{multicols}{2}
    \vfill
    \columnbreak
    \vspace*{\fill}
    \begin{center}
        \begin{forest}
            for tree={edge path={\noexpand\path[\forestoption{edge}] (\forestOve{\forestove{@parent}}{name}.parent anchor) -- +(0,-12pt)-| (\forestove{name}.child anchor)\forestoption{edge label};}, rectangle, draw, align=center}
            [$H_2$
            [$H_0$
                    [$a_0$]
                        [$a_1$]
                ]
                [$H_1$
                    [$a_2$]
                        [$a_3$]
                ]
            ]
        \end{forest}
    \end{center}
    \begin{center}
        \textit{Before removing $a_2$}
    \end{center}
    % Fill a space
    \vfill
    \columnbreak
    \vspace*{\fill}
    % Fill a space
    \begin{center}
        \begin{forest}
            for tree={edge path={\noexpand\path[\forestoption{edge}] (\forestOve{\forestove{@parent}}{name}.parent anchor) -- +(0,-12pt)-| (\forestove{name}.child anchor)\forestoption{edge label};}, rectangle, draw, align=center}
            [$H_4$, edge=blue600, draw=blue600, top color=blue600!0, bottom color=blue600!0
            [$H_0$
            [$a_0$]
                [$a_1$]
            ]
            [$H_3$ , edge=blue600, draw=blue600, top color=blue600!0, bottom color=blue600!0
            [$0$ , edge=blue600, draw=blue600, top color=blue600!0, bottom color=blue600!0]
            [$a_3$]
            ]
            ]
        \end{forest}
    \end{center}
    \begin{center}
        \textit{After removing $a_2$}
    \end{center}
\end{multicols}

\bigbreak

\subsubsection{Pseudocode}

\begin{algorithm}[H]
    \caption{LeanIMT Remove algorithm}\label{remove}
    \begin{algorithmic}[1]
        \Procedure{Remove}{$index$}
        \State $update(index, 0)$
        \EndProcedure
    \end{algorithmic}
\end{algorithm}

\bigbreak

\subsection{Generate Merkle Proof}

\bigbreak

\begin{algorithm}[H]
    \caption{LeanIMT generateProof algorithm}\label{generateProof}
    \begin{algorithmic}[1]
        \Procedure{generateProof}{$index$}
        \State siblings $\gets$ empty list
        \State path $\gets$ empty list
        \For{level from 0 to depth - 1}
        \State isRightNode $\gets$ index is odd
        \If{isRightNode is true} \Comment{It's a right node}
        \State siblingIndex $\gets$ index - 1
        \Else \Comment{It's a left node}
        \State siblingIndex $\gets$ index + 1
        \EndIf
        \State sibling $\gets$ nodes[level][siblingIndex]
        \If{$sibling$ exists}
        \State add isRightNode to path
        \State add sibling to siblings
        \EndIf
        \State index $\gets$ $\lfloor index/2 \rfloor$ \Comment{Divides the index by 2 and discards the remainder.}
        \EndFor
        \State leaf $\gets$ leaves[index]
        \State index $\gets$ reverse path and use the list as a binary number and get the decimal representation
        \State siblings $\gets$ leaves[index]
        \State proof $\gets$ $\{root, leaf , index, siblings \}$
        \State \Return proof
        \EndProcedure
    \end{algorithmic}
\end{algorithm}

\bigbreak

\subsection{Verify Merkle Proof}

\bigbreak

\begin{algorithm}[H]
    \caption{LeanIMT verifyProof algorithm}\label{verifyProof}
    \begin{algorithmic}[1]
        \Procedure{verifyProof}{$index$}
        \State \{ root, leaf, siblings, index \} $\gets$ proof \Comment{Deconstruct the proof}
        \State node $\gets$ leaf
        \For{i from 0 to siblings.length - 1}
        \State isOdd $\gets$ devide index by 2 $i$ times and check if the result is odd
        \If{isOdd is true} \Comment{$node$ is a right child}
        \State node $\gets$ $hash(siblings[i], node)$
        \Else \Comment{It's a left node}
        \State node $\gets$ $hash(node, siblings[i])$
        \EndIf
        \EndFor
        \If{$root$ is equal $node$}
        \State \Return true
        \Else
        \State \Return false
        \EndIf
        \EndProcedure
    \end{algorithmic}
\end{algorithm}

\bigbreak

\section{Implementations}

\bigbreak

\subsection{TypeScript}

\bigbreak

\subsection{Solidity}

\bigbreak

\section{Benchmarks}

\section{Conslusions}

% Example citation in the Introduction section
This document is based on the work of \cite{semaphorev1whitepaper}.

% Allow LaTeX to break lines more flexibly in the bibliography
\sloppy

% Bibliography section
\printbibliography

% This is the end of the document
\end{document}